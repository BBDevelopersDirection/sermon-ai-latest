---
description: Expert-level Flutter, Firebase Firestore, Cloud Functions, and architecture patterns knowledge for AI chat assistance
globs: lib/**/*.dart, firebase/**/*.js, functions/**/*.js, pubspec.yaml, firebase.json
alwaysApply: true
---

# Flutter, Firebase & Architecture Expert

You are an expert in Flutter development, Firebase ecosystem, and software architecture patterns. Use this knowledge to provide high-quality assistance with Flutter apps, Firebase integration, and clean code architecture.

## **Flutter Expertise**

### **State Management Patterns**
- **BLoC Pattern** (Primary for this codebase)
  ```dart
  // ✅ DO: Follow BLoC pattern as used in [bottom_nav_cubit.dart](mdc:lib/screens/after_login/bottom_nav/bottom_nav/bottom_nav_cubit.dart)
  class ExampleCubit extends Cubit<ExampleState> {
    ExampleCubit() : super(ExampleInitial());
    
    Future<void> loadData() async {
      emit(ExampleLoading());
      try {
        final data = await _repository.getData();
        emit(ExampleLoaded(data));
      } catch (e) {
        emit(ExampleError(e.toString()));
      }
    }
  }
  ```

- **State Classes with Equatable**
  ```dart
  // ✅ DO: Use Equatable for state comparison as in [bottom_nav_state.dart](mdc:lib/screens/after_login/bottom_nav/bottom_nav/bottom_nav_state.dart)
  abstract class ExampleState extends Equatable {
    @override
    List<Object?> get props => [];
  }
  ```

### **Widget Architecture**
- **Reusable Components**
  ```dart
  // ✅ DO: Create reusable widgets like [MyAppElevatedButton](mdc:lib/reusable/MyAppElevatedButton.dart)
  class ReusableWidget extends StatelessWidget {
    final String title;
    final VoidCallback onTap;
    
    const ReusableWidget({
      Key? key,
      required this.title,
      required this.onTap,
    }) : super(key: key);
    
    @override
    Widget build(BuildContext context) {
      return ElevatedButton(
        onPressed: onTap,
        child: Text(title),
      );
    }
  }
  ```

- **Custom Scaffold Pattern**
  ```dart
  // ✅ DO: Use custom scaffold wrapper like [my_scaffold_widget.dart](mdc:lib/reusable/my_scaffold_widget.dart)
  // Provides consistent app bar, navigation, and theming
  ```

### **Navigation & Routing**
- **Bottom Navigation Pattern**
  ```dart
  // ✅ DO: Implement bottom navigation as in [bottom_nav_screen.dart](mdc:lib/screens/after_login/bottom_nav/bottom_nav/bottom_nav_screen.dart)
  // Use PageView with BottomNavigationBar for smooth navigation
  ```

### **Performance Optimization**
- **Image Caching**
  ```dart
  // ✅ DO: Use cached_network_image for performance
  CachedNetworkImage(
    imageUrl: imageUrl,
    placeholder: (context, url) => CircularProgressIndicator(),
    errorWidget: (context, url, error) => Icon(Icons.error),
  )
  ```

- **Video Player Optimization**
  ```dart
  // ✅ DO: Use optimized video players like [video_player_using_id.dart](mdc:lib/reusable/video_player_using_id.dart)
  // Implement proper disposal and memory management
  ```

## **Firebase Firestore Expertise**

### **Data Modeling**
- **Collection Structure**
  ```dart
  // ✅ DO: Follow consistent collection naming as in [firestore_variables.dart](mdc:lib/services/firebase/firestore_variables.dart)
  class FirestoreCollections {
    static const String users = 'users';
    static const String reels = 'reels';
    static const String videos = 'videos';
    static const String transactions = 'transactions';
  }
  ```

### **Data Management Services**
- **Service Layer Pattern**
  ```dart
  // ✅ DO: Create dedicated service classes like [firestore_functions.dart](mdc:lib/services/firebase/user_data_management/firestore_functions.dart)
  class UserDataService {
    static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
    
    static Future<void> createUser(UserModel user) async {
      try {
        await _firestore
            .collection(FirestoreCollections.users)
            .doc(user.id)
            .set(user.toMap());
      } catch (e) {
        throw Exception('Failed to create user: $e');
      }
    }
  }
  ```

### **Real-time Data Streaming**
- **Stream-based Data Fetching**
  ```dart
  // ✅ DO: Use streams for real-time data as in video management
  Stream<List<VideoModel>> getVideosStream() {
    return FirebaseFirestore.instance
        .collection(FirestoreCollections.videos)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => VideoModel.fromMap(doc.data()))
            .toList());
  }
  ```

### **Offline Support**
- **Enable Offline Persistence**
  ```dart
  // ✅ DO: Enable offline persistence in main.dart
  FirebaseFirestore.instance.settings = const Settings(
    persistenceEnabled: true,
    cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
  );
  ```

### **Security Rules Best Practices**
- **User-based Access Control**
  ```javascript
  // ✅ DO: Implement proper security rules
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      match /users/{userId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
  }
  ```

## **Firebase Cloud Functions Expertise**

### **Function Structure**
- **Modular Function Organization**
  ```javascript
  // ✅ DO: Organize functions by feature
  const functions = require('firebase-functions');
  const admin = require('firebase-admin');
  
  admin.initializeApp();
  
  exports.createUser = functions.auth.user().onCreate(async (user) => {
    // Handle user creation
  });
  
  exports.processVideo = functions.firestore
    .document('videos/{videoId}')
    .onCreate(async (snap, context) => {
      // Handle video processing
    });
  ```

### **Error Handling**
- **Robust Error Management**
  ```javascript
  // ✅ DO: Implement proper error handling
  exports.exampleFunction = functions.https.onCall(async (data, context) => {
    try {
      // Function logic
      return { success: true, data: result };
    } catch (error) {
      console.error('Function error:', error);
      throw new functions.https.HttpsError(
        'internal',
        'An error occurred while processing your request'
      );
    }
  });
  ```

### **Authentication Integration**
- **Secure Function Calls**
  ```javascript
  // ✅ DO: Verify authentication in functions
  exports.secureFunction = functions.https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'User must be authenticated'
      );
    }
    
    // Function logic
  });
  ```

## **Architecture & Design Patterns**

### **Clean Architecture Principles**
- **Separation of Concerns**
  ```
  lib/
  ├── models/          # Data models
  ├── services/        # Business logic
  ├── screens/         # UI components
  ├── reusable/        # Shared widgets
  ├── network/         # API layer
  └── utils/           # Utilities
  ```

### **Repository Pattern**
- **Data Access Abstraction**
  ```dart
  // ✅ DO: Abstract data access like in [firestore_functions.dart](mdc:lib/services/firebase/user_data_management/firestore_functions.dart)
  abstract class UserRepository {
    Future<UserModel> getUser(String id);
    Future<void> createUser(UserModel user);
    Stream<List<UserModel>> getUsersStream();
  }
  
  class FirebaseUserRepository implements UserRepository {
    // Implementation
  }
  ```

### **Dependency Injection**
- **Service Locator Pattern**
  ```dart
  // ✅ DO: Use service locator for dependency management
  class ServiceLocator {
    static final _instance = ServiceLocator._internal();
    factory ServiceLocator() => _instance;
    ServiceLocator._internal();
    
    final Map<Type, dynamic> _services = {};
    
    void register<T>(T service) {
      _services[T] = service;
    }
    
    T get<T>() => _services[T] as T;
  }
  ```

### **Error Handling Strategy**
- **Consistent Error Management**
  ```dart
  // ✅ DO: Implement consistent error handling like in [dio_client.dart](mdc:lib/network/dio_client.dart)
  class AppError {
    final String message;
    final int? code;
    
    AppError(this.message, [this.code]);
  }
  
  // Use try-catch blocks with proper error propagation
  Future<Result<T, AppError>> safeCall<T>(Future<T> Function() call) async {
    try {
      final result = await call();
      return Result.success(result);
    } catch (e) {
      return Result.failure(AppError(e.toString()));
    }
  }
  ```

## **Performance & Best Practices**

### **Memory Management**
- **Proper Disposal**
  ```dart
  // ✅ DO: Implement proper disposal in widgets
  @override
  void dispose() {
    _controller.dispose();
    _streamSubscription.cancel();
    super.dispose();
  }
  ```

### **Network Optimization**
- **Dio Client Configuration**
  ```dart
  // ✅ DO: Configure Dio client as in [dio_client.dart](mdc:lib/network/dio_client.dart)
  final dio = Dio(BaseOptions(
    baseUrl: baseUrl,
    connectTimeout: Duration(seconds: 30),
    receiveTimeout: Duration(seconds: 30),
  ));
  ```

### **Analytics Integration**
- **Event Tracking**
  ```dart
  // ✅ DO: Track events like in [analytic_logger.dart](mdc:lib/reusable/my_app_firebase_analytics/analytic_logger.dart)
  AnalyticsEngine.logEvent(EventName.userLogin, {
    'method': 'email',
    'timestamp': DateTime.now().millisecondsSinceEpoch,
  });
  ```

## **Testing Strategy**

### **Unit Testing**
```dart
// ✅ DO: Write comprehensive unit tests
group('UserCubit', () {
  late UserCubit userCubit;
  late MockUserRepository mockRepository;
  
  setUp(() {
    mockRepository = MockUserRepository();
    userCubit = UserCubit(mockRepository);
  });
  
  test('should emit loading then loaded state', () async {
    // Arrange
    when(mockRepository.getUser(any)).thenAnswer((_) async => mockUser);
    
    // Act
    userCubit.loadUser('123');
    
    // Assert
    expect(userCubit.state, isA<UserLoading>());
    await expectLater(userCubit.stream, emits(isA<UserLoaded>()));
  });
});
```

## **Security Considerations**

### **Data Validation**
- **Input Sanitization**
  ```dart
  // ✅ DO: Validate all inputs
  static bool isValidEmail(String email) {
    return EmailValidator.validate(email);
  }
  
  static bool isValidPassword(String password) {
    return password.length >= 8 && 
           password.contains(RegExp(r'[A-Z]')) &&
           password.contains(RegExp(r'[0-9]'));
  }
  ```

### **Firebase Security**
- **Authentication Flow**
  ```dart
  // ✅ DO: Implement secure auth flow like in [otp_service.dart](mdc:lib/services/firebase/otp_service.dart)
  // Use Firebase Auth with proper error handling
  // Implement token refresh mechanisms
  ```

## **Common Anti-Patterns to Avoid**

- **❌ DON'T**: Put business logic in UI widgets
- **❌ DON'T**: Make direct Firestore calls from widgets
- **❌ DON'T**: Forget to dispose controllers and streams
- **❌ DON'T**: Hardcode API endpoints or secrets
- **❌ DON'T**: Skip error handling in async operations
- **❌ DON'T**: Use setState in StatefulWidget when BLoC is available
- **❌ DON'T**: Create deep widget trees without extracting components

## **Code Quality Standards**

- **Follow Dart/Flutter linting rules** as configured in [analysis_options.yaml](mdc:analysis_options.yaml)
- **Use meaningful variable and function names**
- **Add comprehensive documentation for complex functions**
- **Implement proper null safety patterns**
- **Use const constructors where possible**
- **Follow the existing codebase patterns** found in [lib/](mdc:lib/) directory

This expertise should guide all Flutter and Firebase development decisions, ensuring high-quality, maintainable, and scalable code.